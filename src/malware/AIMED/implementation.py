import os
import gp
import json
import requests
from random import choice
from shutil import copyfile
from datetime import datetime   
from time import time, sleep, strftime, gmtime
from subprocess import call, check_output, CalledProcessError, Popen, PIPE
from joblib import dump, load
from keras.models import load_model
import functions as f
import manipulate as m
from conware.extract_features import extract_single_sample_feature
import warnings
warnings.filterwarnings("ignore")


#				HANDLE INPUT PARAMETERS


def handling_input(args): 
	'''
		Handle input entered on terminal when calling AXMED
	'''
	files_expected = detection_threshold = -1
	rounds = files_expected**3 if files_expected > 9 else 100
	if len(args) <= 6:
		n = int(args[2])	
		files_expected = int(args[4])
	elif len(args) > 6:  
		n = int(args[2])
		if args[3] == '-r': 
			rounds = int(args[4])
		elif args[3] == '-m': 
			files_expected = int(args[4])
			if args[5] == '-r':
				rounds = int(args[6])
			else:
				rounds = files_expected**3 if files_expected > 9 else 100
		elif args[7] == '-t': 
			detection_threshold = int(args[8])
			rounds = 100
		if len(args) > 8: 
			if args[7] == '-m' and not args[5] == '-m': 
				files_expected = int(args[8])
				rounds = files_expected**3 if files_expected > 9 else 100
			elif args[7] == '-t' and not args[5] == '-t':
				detection_threshold = int(args[8])
				rounds = 100
			else: 
				raise ValueError('Argument not accepted: {} {}. Please check usage with -h'.\
				format(args[7], int(args[8])))
			if len(args) > 10:
				if args[9] == '-t' and not (args[7] == '-t' or args[7] == '-m' or \
				args[5] == '-t' or args[5] == '-m'): 
					detection_threshold = int(args[10])
					rounds = 100
				else: 
					raise ValueError('Arguments not accepted: {} {}. Please check usage with -h'.\
					format(args[9], int(args[10])))
					   		
	return  n, rounds, files_expected, detection_threshold


#				IMPLEMENTATION AIMED / ARMED FRAMEWORKS


def aimed(bin_bytes, sample, size_population, length_sequence, files_expected, threshold, model_path, use_case, model_arch,  scaler_path): 
	'''
		AIMED: Automatic Intelligent Malware Modifications to Evade Detection
		This function implements GP to find PE adversarial examples. 
		
		Input: 
			bin_bytes: binaries from input malware sample
			sample: malware sample in terminal
			size_population: population size for GP (Default: 4)
			length_sequence: length of perturbation sequence
			files_expected: number of malware mutations expected as output
			scanner: commercial AV or malware model classifier 
	'''



	# Create a dict with all perturbations
	actions = f.actions_vector(m.ACTION_TABLE.keys())
	
	# Inject children sequences to S to create four S'
	mutation = {}
	mutation['Malware_Bytes'], mutation['Malware_Sample'], mutation['Actions'], \
	mutation['Files_Expected'], mutation['hash_sample'], = \
	bin_bytes, sample, actions, files_expected,  f.hash_files(sample)
	
	# Call evolution algorithm to find successfull mutations 
	print('\n### AIMED: Automatic Intelligent Malware Modifications to Evade Detection ###')
	population = gp.Population(size=size_population, length_sequence=length_sequence, show_sequences=True)
	scaler = load(scaler_path) 
	return population.generation(mutation=mutation, threshold = threshold, model_path=model_path, use_case=use_case, model_arch=model_arch, scaler=scaler)	
	
#				MALWARE ANALYSIS STAGE (LOCAL)


def malware_analysis(mod_sample, json_send): 
	'''
		Analyze malware with sandbox Cuckoo
		
		Input: 
			mod_sample: Compiled version of modified malware mutation 
			json_send: JSON status after sending mutation to local sandbox for analysis
			useVT: Boolean value indicating whether VirusTotal is used or detection will be performed locally
			CSV: Data structure with information to save on DB 
	'''
	
	loops = 0
	start = time()
	functionality = False
	
	# Show report from analisys sandbox: report URL + Job ID
	url_sample = 'http://192.168.XX.XXX:8090/analysis/' + str(json_send['task_id']) + '/summary'
	print('\nFull analysis report: {}\n\nStatus:'.format(url_sample))   
      
    # Using sleep in loop to space requests to sandbox may improve results
	firstPrintR, firstPrintW, firstPrintRep = True, True, True
	while True: 
		try: 
			v = f.get_summary_local_sandbox(json_send['task_id'], 'view')
			view_status = v['task']['status']
			if view_status == 'completed' and firstPrintRep: 
				print('Analysis finished. Generating report..')
				firstPrintRep = False
			elif view_status == 'pending' and firstPrintW:
				print('Waiting in queue to be analyzed..')
				firstPrintW = False
			elif view_status == 'running' and firstPrintR: 
				print('Analysis in progress..')
				firstPrintR = False
			elif view_status == 'reported':
				print('Report finished.')
				break
			sleep(0.2)

		except (requests.ConnectionError, requests.Timeout, requests.ConnectTimeout) as e: 
			print('Connection issues or API not available:\n{}'.format(e)) 

    # Check the likelihood that malware runs based on report
	err = 'CuckooPackageError: Unable to execute the initial process, analysis aborted.\n'
	r = f.get_summary_local_sandbox(json_send['task_id'], 'report')
	report = r['debug']['cuckoo']
	duration = r['info']['duration']
	if err not in report and duration >= 15: 
		functionality = True
		print('\nResults: WORKING')
        
        # Show analysis time in hh:mm:ss
		f.time_me(start)
    
	elif err not in report and duration < 15: 
		print('\nResults: It could not be determined (score = {} â€“ duration = {})'.format(r['info']['score'], duration))
		
		# Show analysis time in hh:mh:ss
		f.time_me(start)
				 
	elif err in report:
		print('\nResults: Mutation is corrupt')

	return functionality, url_sample 

	
#				MALWARE ANALYSIS STAGE (REMOTE)



# MALWARE DETECTION STAGE (LOCAL)
def check_funcionality(path_to_sample):
	directory = 'Z:\\'
	vm_path = directory+path_to_sample
	valid = False
	try:						
		#status = check_output(['timeout', '10', 'VBoxManage', 'guestcontrol', 'sandbox', '--username', 'vagrant', '--password', 
		#'vagrant', 'run', '--exe', path_to_sample])
		#Timeout does not have any effect here due to the required use of shell==True
		status = check_output([ 'C:\\Program Files\\Oracle\\VirtualBox\\VBoxManage.exe', 'guestcontrol', 'sandbox_nn', '--username', 'vagrant', '--password', 
		'vagrant', 'run', '--exe',vm_path ],  timeout=3,  cwd='C:\\Program Files\\Oracle\\VirtualBox')
		
	except Exception as err:
		if 'returned non-zero exit status 1.' in str(err): 
			print('\nMutation corrupt!\n')
			valid = False
		else:
			print('\nMutation WORKING!\n')
			valid = True
	try:
		status = check_output([ 'C:\Program Files\Oracle\VirtualBox\VBoxManage.exe', 'guestcontrol', 'sandbox_nn', 'closesession', '--all'], timeout=2,  cwd='C:\\Program Files\\Oracle\\VirtualBox')
	except Exception as err:
		print(err)
	return valid



def malware_detection(mutation, threshold, model_path, model_arch, scaler):
	''' 
		Detecting malware samples using local scanners.
		Use malware classifiers from industry or academia: 
		Gradient Boosting [Anderson et al. 2018]: Trained with 100k
		malicious and benign samples and achieves ROC-AUC = 0.993
		Threshold of 0.9 correponds to 1% FPR at 90% TPR
		A functionality (beta)-test has been added that overcomes the
		processing time of Cuckoo by 1/3 reducing from 45 to 15 s.
	'''
	
	detect = False
	vm = "Windows7-Detection"
	av_model = load_model(model_path)
	score,features = f.get_score_local(mutation , av_model, model_arch, scaler)	
	if score > threshold: # As per paper
		print('\nMalware detected.\n') 
		detect = True
	else: 
		print('\nSample not detected.\n')
		detect =  False
	return detect,features,score

