import os
import sys 
import csv
import random
import zipfile
import requests
import subprocess
import pandas as pd
import numpy as np
import joblib 
import lief # pip install lief==0.9.0
from hashlib import sha256
from shutil import copyfile
from time import time, strptime, sleep
from datetime import datetime, timedelta 
from subprocess import call, check_output, CalledProcessError, Popen, PIPE, run
import manipulate as m
from pefeatures import PEFeatureExtractor
sys.path.append('../')
import conware
from conware.extract_features import extract_single_sample_feature

import warnings
warnings.filterwarnings("ignore")


LIEF_EXCEPTIONS = (lief.bad_file, lief.bad_format)

def time_me(start_time):
	'''
		Timer returning output in following format HH:MM:SS
	'''
	# Show total time in hh:mm:ss
	m, s = divmod(time() - start_time, 60)
	h, m = divmod(m, 60)
	print('\nTotal processing time: %02d:%02d:%02d\n' % (h, m, s))
	return '%02d:%02d:%02d' % (h, m, s)

def readfile(filename):
	'''
		Convert file into bytes
	'''
	with open(filename, "rb") as b:
		b_bytes = b.read()

	#with open(filename ,'rb') as infile:
		#b_bytes = lief.PE.parse(infile, name="")
	return b_bytes



def hash_files(filename):
	'''
		Return SHA256 of a file
	'''
		
	h = sha256()
	with open(filename, 'rb', buffering=0) as f:
		for b in iter(lambda : f.read(128*1024), b''):
			h.update(b)
	return h.hexdigest()



def url_ok(url):
	'''
		Check URL status 
	'''
	
	r = requests.get(url, timeout=10)
	return r.status_code
	

def create_random_actions(size_of_actions, n):
	'''
		Return vector filled with random perturbations
	'''
	
	random.seed() 
	random_actions = random.sample(range(size_of_actions), n)
	return random_actions
	
def actions_vector(actions_dict): 
	'''
		Creating a dict with all available perturbations
	'''
	
	actions = {i: act for i, act in enumerate(actions_dict)}
	return actions	

def build_bytes(input_bytes, pert_number, code, sample_path, generationNumber, gene_num): 
	'''
		Compile a malware mutations after perturbations are injected
		
		Input: 
			input_bytes: input malware in bytes
			pert_number: number of perturbations injected to keep track in name
	'''
	try: 
		new_binary = lief.PE.parse(list(input_bytes))

	except LIEF_EXCEPTIONS as e:
		print("No PE file created as LIEF returned:", str(e))
		return None
	
	new_binary = lief.PE.parse(list(input_bytes))
	builder = lief.PE.Builder(new_binary)
	builder.build_imports(True) 
	builder.patch_imports(True) 
	builder.build()

	idx = ''.join(map(str, code))
	original_sample = sample_path.split('\\')[-1]
	original_sample = original_sample.split('.')[0]
	vm_file = original_sample + '_' + str(generationNumber) +'_'+str(gene_num)+'_'+ idx +'_m.exe'
	mutation_file = 'functional_samples/'+ vm_file
	builder.write(mutation_file) 

	return mutation_file, original_sample, vm_file

	
def rec_mod_files(input_bytes, actions, chosen_actions, perturbs, pert_number,  sample_path, generationNumber, gene_num):
	'''
		Recursive function to inject perturbations to input malware sample
		
		Input: 
			input_bytes: input malware in bytes 
			actions: all possible perturbations 
			chosen_actions: vector of perturbations to inject
			perturbs: number of perturbation being injected on this iteration
			pert_number: total number of perturbations to inject
	'''
	
	if perturbs == -1: 
		return build_bytes(input_bytes, pert_number, chosen_actions, sample_path, generationNumber, gene_num)
	else: 
		try:
			# Create an instance of MwManip (manipulate.py)
			malman = m.MalwareManipulator(input_bytes)
			# Call one by one all chosen_actions from n to 0
			print("Perturbation: {} â€“ Perform action: {}".format(perturbs, actions[chosen_actions[perturbs]]))
			function = ('malman.' + actions[chosen_actions[perturbs]])
			# Inject perturbation (check for overhead)
			mod_bytes = eval(function)(input_bytes)
		#except lief.bad_format as e:
		except Exception as e:
			print('LIEF returned the following error: ', e)
			return None, None, None

		return rec_mod_files(mod_bytes, actions, chosen_actions, perturbs-1, pert_number, sample_path, generationNumber, gene_num)
		#return mod_bytes

#				CALCULATE DIFFERENCE BETWEEN TWO PEs

def get_difference(sample1, sample2):
	''' 
		Calculate the difference between two PE: 
		
		Input: 
			sample1: original sample S 
			sample2: mutation S' 
	'''	
	
	s1_bytes = readfile(sample1)
	s2_bytes = readfile(sample2)
	### Replace "Path" with the path where the modified sample is saved
	sample2  = "Path" + sample2
	sample1 = sample1.replace( "D:", "\mnt\d")
	sample1 = sample1.replace( "\\", "/")
	sample2 = sample2.replace( "C:", "\mnt\c")
	sample2 = sample2.replace( "\\", "/")
	try:
		# Use -n to compare only until smallest file ends to avoid EOF message		   
		compare_samples = subprocess.Popen(
			[ 'wsl', 'cmp', '-l', '-n', str(min(len(s1_bytes), len(s2_bytes))), sample1, sample2],
			stdout=subprocess.PIPE)
		out_compare_samples, err_compare_samples = compare_samples.communicate()

	except subprocess.CalledProcessError as e:
		raise RuntimeError("command '{}' return with error (code {}): {}".format(e.cmd, e.returncode, e.output))

	#print('Time CMP: {} s'.format(round((time()-start_cmp), 2)))
	compare_samples.kill()

	return len(out_compare_samples)

		
def send_local_sandbox(sample):

	'''
		API implementation to send a file for analysis using Cuckoo sandbox (local)
	'''
	#print(f_name)
	submitUrl = "http://:8090/tasks/create/file"
	data = {'timeout': '30'}
	headers = {"Authorization": "Bearer "}

	#with open(f_name, 'rb',) as sample:
	files = {"file": ("new_mutation", sample)}
	r = requests.post(submitUrl, headers=headers, data=data, files=files)
	try:
		if r.status_code == 200: 
			print("\nFile successfully submitted to analysis:")
			return r.json()
		else:
			print("Error code: {}, returned when submitting: ".format(r.status_code ))
			return r.status_code
		sample.close()
	
	except requests.exceptions.HTTPError: 
		print(err.read())
		traceback.print_exc()
	
		
def get_summary_local_sandbox(id, option): 
	'''
		API implementation to retrieve report from a file analyzed using the Cuckoo sandbox
	'''
	headers = {"Authorization": "Bearer qv4ezSu5z5INAodQsND2lg"}

	# Options: view = short report | report = extensive report
	if option == 'view': 
		r = requests.get('http://:8090/tasks/view/'+str(id), headers=headers)
	else: 
		r = requests.get('http:///tasks/report/'+str(id), headers=headers)	
	return r.json()


#				DATABASE.CSV CREATION & UPDATE



def write_dict_CSV(csv_file, CSV, fields):
	'''
		Function to save dict into CSV file
		
		Input: 
			csv_file: CSV file to create
			CSV: dict with values to store 
			fields: pre-defined column names
	'''
	
	try: 
		if not os.path.isfile(csv_file):							  
			with open(csv_file, 'w') as fi:
				writer = csv.DictWriter(fi, fieldnames=fields)
				writer.writeheader()
				writer.writerow(CSV) 
		else: 
			with open(csv_file, 'a') as fi:
				writer = csv.DictWriter(fi, fieldnames=fields, extrasaction='ignore') 
				writer.writerow(CSV)

	except IOError as err:
		print("Exception: {}".format(err))    


def save_functional_samples(mod_sample, code, sample_path, generationNumber, gene_num):
	idx = ''.join(map(str, code))
	original_sample = sample_path.split('\\')[-1]
	original_sample = original_sample.split('.')[0]
	vm_file = original_sample + '_' + str(generationNumber) +'_'+str(gene_num)+'_'+ idx +'_m.exe'
	mutation_file = 'functional_samples/'+ vm_file
	file = open(mutation_file, "wb")
	file.write(mod_sample)
	file.close()
	return mutation_file, original_sample,vm_file

def append_data_df(df_path, new_rows ):
	with open(df_path, "a", newline="") as f:
		writer = csv.writer(f)
		writer.writerows(new_rows)

			
# GET SCORE OF MALICIOUSNESS USING PRE-SAVED MALWARE CLASSIFIER MODEL 

def load_av(filename): 
	''' 
		Load pre-saved model (filename = .pkl) 
	'''
	
	loaded_model = joblib.load(filename)
	return loaded_model
	
def get_score_local(path, local_model, model_arch, scaler):
	''' 
		Extract features from malware and get score using pre-saved model 
	'''
	features = extract_single_sample_feature(path)

	# Get malicious score from a single sample
	# local_model.predict_proba)
	if model_arch == "random_forest":
		score = local_model(features)
	elif model_arch == "neural_network":
		features_np = np.array(features).reshape(1, -1)
		features_scaled = scaler.transform(features_np)
		score = local_model(features_scaled)[0,-1] 
		score = float(score)
	return score, features

def restore_vm():
	dir = "C:\Program Files\Oracle\VirtualBox" 
		# Start & restore the VM (headless = invisible)
	state_received = False
	while state_received == False:
		try:
			state = check_output(['VBoxManage', 'showvminfo', 'sandbox_nn'], cwd=dir, shell=True ).decode('UTF-8')
			state_received = True
		except Exception as error:
			sleep(0.5)
			state_received = False
	#if "running" in state:
		#call(['VBoxManage', 'controlvm', 'sandbox', 'poweroff'],cwd=dir, shell=True)
		#call(['VBoxManage', 'startvm', 'sandbox', '--type', 'headless'],cwd=dir, shell=True) 
	if "powered off" in state or "saved" in state:
		print("State", state)
		run(['VBoxManage', 'snapshot', 'sandbox_nn', 'restore', 'Snapshot1'],cwd=dir, shell=True)
		sleep(0.5)
		run(['VBoxManage', 'startvm', 'sandbox_nn', '--type', 'headless'],cwd=dir, shell=True)
		sleep(0.5)
	elif "paused" in state: 
		call(['VBoxManage', 'controlvm', 'sandbox_nn', 'resume', '--type', 'headless'],cwd=dir, shell=True)