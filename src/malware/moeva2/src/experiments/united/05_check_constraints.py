import os
import warnings
import time
from itertools import combinations
from pathlib import Path

import joblib
import numpy as np

from src.attacks.moeva2.classifier import Classifier
from src.attacks.moeva2.feature_encoder import get_encoder_from_constraints
from src.attacks.moeva2.moeva2 import Moeva2
from src.attacks.moeva2.objective_calculator import ObjectiveCalculator
from src.attacks.moeva2.utils import results_to_numpy_results, results_to_history
from src.config_parser.config_parser import get_config, get_config_hash, save_config
from src.experiments.botnet.features import augment_data
from src.experiments.united.utils import get_constraints_from_str
from src.utils import Pickler, filter_initial_states, timing, in_out
from src.utils.in_out import load_model

warnings.simplefilter(action="ignore", category=FutureWarning)
warnings.simplefilter(action="ignore", category=RuntimeWarning)

# config = in_out.get_parameters()


@timing
def run():
    os.environ["CUDA_VISIBLE_DEVICES"] = "-1"
    out_dir = config["dirs"]["results"]
    config_hash = get_config_hash()
    mid_fix = f"{config['attack_name']}"
    metrics_path = f"{out_dir}/metrics_{mid_fix}_{config_hash}.json"
    if os.path.exists(metrics_path):
        print(f"Configuration with hash {config_hash} already executed. Skipping")
        exit(0)

    Path(config["dirs"]["results"]).parent.mkdir(parents=True, exist_ok=True)
    print(config)

    # ----- Load and create necessary objects

    if config["paths"].get("important_features", False):
        constraints = get_constraints_from_str(config["project_name"])(
            config["paths"]["features"],
            config["paths"]["constraints"],
            config["paths"].get("important_features")
        )
    else:
        constraints = get_constraints_from_str(config["project_name"])(
            config["paths"]["features"],
            config["paths"]["constraints"],
        )

    X_initial_states = np.load(config["paths"]["x_candidates"])
    X_initial_states = filter_initial_states(
        X_initial_states, config["initial_state_offset"], config["n_initial_state"]
    )


    # ----- Check constraints

    constraints.check_constraints_error(X_initial_states)

    # ----- Copy the initial states n_repetition times
    # X_initial_states = np.repeat(X_initial_states, config["n_repetition"], axis=0)

   
if __name__ == "__main__":
    config = get_config()
    run()
