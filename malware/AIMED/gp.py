#!/usr/bin/env python3

# Genetic Programming implementation:
# Inspired on https://github.com/lowerkey/genetic_programming

# Use numpy.random instead or random.random() to leverage the Mersenne Twister implementation 
# to generate pseudorandom numbers: http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf

# Estimated processing: (generations-1)*2 + size_population * func_test(mutation) * detect(mutation)

from math import floor
import os
import pickle 
from time import time, sleep
import subprocess
import pandas as pd
import numpy.random as nr


import functions as f
import implementation as i
import conware
from conware.extract_features import extract_single_sample_feature


import warnings
warnings.filterwarnings("ignore")

class Chromosome:

    def __init__(self, code):
        self.code = code  
        self.cost = 0 	  
        
    def __getitem__(self, index): 
        return self.code[index]
		
    def __setitem__(self, index, value): 
        self.code[index] = value
 

    def mate(self, chromosome):
		
        ''' Perform crossover between two genes '''
		
        middle = int(floor(len(self.code)/2))
        return [Chromosome(self.code[:middle] + chromosome.code[middle:]),
                Chromosome(chromosome.code[:middle] + self.code[middle:])]

    def mutate(self, chance):
		
        ''' Random genetic mutation on genes '''
		
        if nr.random() < chance:
            return
        else:
            index = int(nr.random() * len(self.code))
            self.code[index] = int(nr.random() * 9)  # 10 perturbations in vector

    def random(self, length):
		
        ''' Generate random genes '''
		
        code = []
        for i in range(length):
            code.append(int(nr.random() * 9)) 
        self.code = code

    def calcCost(self, detected, generation, diff): 
		
        ''' Calculate the cost of each sample state: corrupt, detected, and evasive '''
		
		#status == 'corrupt'
        if detected == '':
            self.cost = 10 + generation + diff       
        #status = 'detected'
        elif detected == True:           
            self.cost = 50 + generation + diff 
        #status = 'evasion'
        elif detected == False:           
            self.cost = 100 + generation + diff


class Population:

    def __init__(self, size, length_sequence, show_sequences):
        self.members = []
        self.mutations_processed = []
        self.length_sequence = length_sequence
        self.new_evasions = 0
        self.corrupt_mutations = 0
        self.diff_samples = 0
        for i in range(size):
            chromosome = Chromosome('')
            chromosome.random(self.length_sequence)
            self.members.append(chromosome)
        self.generationNumber = 1
        
        # Show the sequences & fitness of the fittest members
        self.show_sequences = show_sequences
                    
    def calcCosts(self, detected, generation, diff):
        for member in self.members:
            member.calcCost(detected, generation, diff) 

    def mutate(self, chance):
        for member in self.members:
            member.mutate(chance)

    def selection(self):
		
        ''' Select the fittest members for the next generation '''

        print("\n### Generation {} ###".format(self.generationNumber))

		# Sort cost descending to group highest fitness at the beginning of the list 
        self.members = sorted(self.members, key=lambda member: member.cost, reverse=True)
		
        # If both parents are evasive & there are other genes evasive on the list, swap one of them
        if self.members[0].code	== self.members[1].code and self.members[0].cost >= 100:   
            for z in range(2, len(self.members)-1): 
                if self.members[z].cost >= 100 and self.members[z].code != self.members[0].code and self.members[z].code != self.members[1].code:
                    self.members[0] = self.members[z]
                    break			
                    
        # Show updated population (Generations use size_population-2 because of breeding. Eg. size = 6 - 2 'children' = 4 -> 1st generation only shows 4 genes in Population)
        print('\n# Population: ', end='')
        if self.generationNumber == 1:  
            [print(self.members[z].code, self.members[z].cost, end=' # ') for z in range(len(self.members)-2)]
        else:
            [print(self.members[z].code, self.members[z].cost, end=' # ') for z in range(len(self.members))]
        print('\n')
        
    def listEvasions(self, print_results): 
		
        ''' Show evasive members '''
		
        if print_results == True: 
            return [print(sequence) for sequence in self.mutations_processed if sequence[1]>=100]
        else: 
            sequence_list = []
            [sequence_list.append(sequence) for sequence in self.mutations_processed if sequence[1]>=100]			
            return sequence_list		
   
    def allEvasion(self):  
		
        ''' Check whether all members are evasive '''
		
        duplicates = []
        if self.members[0].cost	< 100:
            return False
        for z in range(len(self.members)-1): 
            if self.members[z].cost == self.members[z+1].cost:
                pass				
            else:
                return False
                
        # Create a list with only member.code to make it hashable
        for k in self.members:
            duplicates.append(k.code)
            
        # Make sure there are no duplicated genes in the population 
        if len(set(map(tuple, duplicates))) == len(self.members):
            print('\nAll sequences in the population lead to evasive mutations!')  
            print('\nPopulation: ', end='')
            [print(self.members[z].code, self.members[z].cost, end=' # ') for z in range(len(self.members))]            
            return True	

    def generation(self, mutation, threshold, model_path, use_case, model_arch, scaler): 
		
		# Run until termination criteria are met
        start_generation = time()
        while self._generation(mutation, threshold, model_path, use_case, model_arch, scaler)==False:
            print("Computation time for this generation:")
            f.time_me(start_generation)
            start_generation = time()
            pass

        # Once finished, show evasive sequences if show_sequences=True 
        if self.show_sequences: 
            if self.new_evasions:
                print('\n### All evasive sequences found: ###\n')
                self.listEvasions(print_results=True)
            else: 
                print('\n### No evasive sequences found ###')
            return self.new_evasions, self.corrupt_mutations 
        else:
            return self.generationNumber
        
    def _generation(self, mutation, threshold, model_path, use_case, model_arch, scaler):
        # Call selection before breeding
        self.selection()
        # Breeding & mutating and adding children to the members list for Selection afterwards
        children = self.members[0].mate(self.members[1])
        children[0].mutate(0.1)
        children[1].mutate(0.1)        
        self.members[-2] = children[0]
        self.members[-1] = children[1]
        gene_num = 0
        features = []
        info = []
        for member in self.members:
            existing_member = False
            ## If mutation was processed retrieve fitness value & avoid processing again
            for x in range(len(self.mutations_processed)):
                if self.mutations_processed[x][0] == member.code:
                    member.cost = self.mutations_processed[x][1]
                    print('\nFitness: {}'.format(member.cost))
                    existing_member = True
                    break
                    
            if  not existing_member:
                f.restore_vm()

				# First generation calculates all genes, then breeds+mutates 2 members per generation
                gene_num += 1	
                if self.generationNumber == 1: 
                    print('# Calculating fitness for gene {} of {}: {} #'.format(gene_num, len(self.members), member.code))					
                else: 
                    print('# Calculating fitness for child {}: {} #\n'.format(gene_num, member.code))

    			# Inject children sequences to S to create four S'
                mutation_file, original_sample, vm_file = f.rec_mod_files(mutation['Malware_Bytes'], mutation['Actions'], member.code, len(member.code)-1, len(member.code), mutation['Malware_Sample'], self.generationNumber, gene_num )
                #mutation_file, original_sample, vm_file = f.save_functional_samples(mod_sample, member.code, mutation['Malware_Sample'], self.generationNumber, gene_num)
                if mutation_file==None:
                    break
	            # call functionality test
                functional = i.check_funcionality(vm_file)
                #json_send = f.send_local_sandbox(mod_sample) 
               
		        # analyze functionality results (set usevt to virustotal report)
                #start_cuckoo_analyze = time()	
                #functional = i.malware_analysis(mod_sample, json_send)
                #print("Cuckoo analyze time")
                #f.time_me(start_cuckoo_analyze)

            # Restore a clean snapshot for consistency
                #  analyze detection results
                if functional == True: 
                    print('running detection for gene:', member.code)
                    try:
                        detected, features_i, score = i.malware_detection(mutation_file, threshold, model_path, model_arch, scaler)
                    except Exception as e:
                        print(e)
                        break

                    if detected==False:
                        self.new_evasions += 1
                    features.append(features_i)
                    info.append([original_sample, mutation_file, score] )
                    
                    # calculate difference between original sample and mutation
                    self.diff_samples = f.get_difference(mutation['Malware_Sample'], mutation_file)
                    diff_adjusted = round(self.diff_samples/100000, 3) # constant empirically defined as test
                    
                    # set cost to s' instances
                    member.calcCost(detected, self.generationNumber, diff_adjusted) 
                else:
		    	# send empty when corrupt 
                    member.calcCost('', self.generationNumber, 0)
                    self.corrupt_mutations += 1
                try:
                    os.remove(mutation_file)
                except Exception as e:
                    print("This file should be removed manually", mutation_file)
            
                self.mutations_processed.append((member.code, member.cost))

                print('sequence: {} â€“ fitness: {}\n'.format(member.code, member.cost))
          
            #termination: number of evasions achieved or number of generations reach termination defined 
        termination_per_generation = mutation['Files_Expected']**2 if mutation['Files_Expected']  > 8 else 10
        if self.new_evasions >= mutation['Files_Expected'] or self.generationNumber == termination_per_generation: 
            # This should be a separate function
            f.append_data_df(f'data/out/{model_arch}/{use_case}/functional_samples_features.csv', features)
            f.append_data_df(f'data/out/{model_arch}/{use_case}/info_df.csv', info )
            
            return True
        else: 
            print('# evasive mutations found: {} #'.format(self.new_evasions))
            print('# corrupt mutations found: {} #\n'.format(self.corrupt_mutations))               
            self.generationNumber += 1
            f.append_data_df(f'data/out/{model_arch}/{use_case}/functional_samples_features.csv', features)
            f.append_data_df(f'data/out/{model_arch}/{use_case}/info_df.csv', info )
            return False